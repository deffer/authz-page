package nz.ac.auckland.auth.contract

import com.fasterxml.jackson.annotation.JsonIgnore
import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import nz.ac.auckland.auth.config.ApplicationContextProvider
import nz.ac.auckland.auth.endpoints.CryptoHelper
import org.springframework.beans.factory.annotation.Autowired

import java.util.regex.Matcher
import java.util.regex.Pattern

@JsonIgnoreProperties(ignoreUnknown = true)
class Token {

	// for consent tokens, the format of access_token field is "{consent_expires_in}hmac{signature}"
	//   where signature is hmac_265 of "{salt}s{consent_expires_in}"
	//   for consents that never expires, consent_expires_in is set to "0000" in both signature and access_token
	// for consent tokens, expires_in is always set to 0, otherwise kong would delete it after 14 days
	String access_token
	String api_id
	String authenticated_userid
	Long created_at // 1506636019000
	String credential_id
	Long expires_in // 7200
	String id
	String scope // "identity-read identity-write default"
	String token_type //"bearer"


	// if its a consent token, this will be set to a millis value after calling isConsentToken()
	@JsonIgnore
	Long consentExpiresIn // 0 for never.
	@JsonIgnore
	Boolean consentToken = null // null indicates that it wasnt initialized yet (need to call init() )
	@JsonIgnore
	CryptoHelper cryptoHelper

	static final String CONSENT_USER_SUFFIX="_consent"
	static final String CONSENT_NO_EXPIRE_MS="0000"
	static final String TOKEN_TYPE="bearer"

	static def generator = { String alphabet, int n ->
		return new Random().with {
			(1..n).collect { alphabet[ nextInt( alphabet.length() ) ] }.join('')
		}
	}

	public static Token generateConsentToken(Long consentExpiresInS, String userId,
	                                         String scope, String apiId, String credentialsId){
		long currentTime = System.currentTimeMillis()

		String salt = generator( ('0'..'9').join(''), 12 )

		Token result = new Token(
				//created_at: currentTime, // doesnt work as expected
				authenticated_userid: userId+CONSENT_USER_SUFFIX,
				api_id: apiId, expires_in: 0, credential_id: credentialsId,
				scope: scope, token_type: TOKEN_TYPE
		)
		String consentExpirationString = consentExpiresInS == 0l ? CONSENT_NO_EXPIRE_MS : consentExpiresInS.toString()
		String signMessage = "${salt}s$consentExpirationString"
		result.access_token = "${signMessage}hmac"+result.getSignature(signMessage)
		return result
	}

	@JsonIgnore
	Pattern consentTokenPattern = ~/^(\d+)s(\d)hmac(.*)/

	boolean isConsentToken() {
		if (consentToken == null)
			init()
		return consentToken?.booleanValue()
	}

	public void init(){

		if (!authenticated_userid || !access_token || !authenticated_userid?.endsWith(CONSENT_USER_SUFFIX)){
			consentToken = Boolean.FALSE
			return
		}

		Matcher matcher = consentTokenPattern.matcher(access_token)
		if (matcher.matches()){
			def firstMatch = matcher[0]
			String salt = firstMatch[1]
			String consentExpirationString = firstMatch[2]
			String signature = firstMatch[3]

			// check if it was generated by us with the current key
			String signMessage = "${salt}s$consentExpirationString"
			String calculatedSignature = getSignature(signMessage)
			if (signature == calculatedSignature){
				if (consentExpirationString == CONSENT_NO_EXPIRE_MS)
					this.consentExpiresIn = 0
				else
					this.consentExpiresIn = Long.parseLong(consentExpirationString)

				consentToken = Boolean.TRUE
				return
			}
		}
		consentToken = Boolean.FALSE
	}

	String getSignature(String signMessage){
		if (!cryptoHelper)
			cryptoHelper = ApplicationContextProvider.getBean(CryptoHelper.class)

		return cryptoHelper.sign(signMessage)
	}
}
